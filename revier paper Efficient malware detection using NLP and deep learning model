
# Deteksi Malware Efisien Menggunakan NLP dan Deep Learning: Tinjauan Riset

## Latar Belakang dan Urgensi Deteksi Malware

Keberadaan malware telah menjadi ancaman serius dalam dunia digital modern. Seiring dengan meluasnya penggunaan komputer dan perangkat cerdas, insiden serangan malware terus meningkat secara signifikan. Contohnya, salah satu jenis malware paling merusak, **ransomware**, dilaporkan telah menginfeksi lebih dari **230 juta perangkat** di seluruh dunia, di mana **47%** di antaranya menimpa perusahaan-perusahaan besar di Amerika Serikat. Malware (malicious software) dirancang untuk menyusup, merusak, atau mengambil alih sistem komputer, server, bahkan jaringan, sering kali dengan tujuan mencuri data sensitif atau mengganggu operasi sistem. Fenomena *malware epidemic* ini menimbulkan urgensi bagi komunitas keamanan siber untuk mengembangkan metode deteksi malware yang lebih **efektif** dan **adaptif**. Deteksi yang handal sangat penting untuk melindungi infrastruktur informasi, mencegah kerugian finansial, dan menjaga kepercayaan pengguna terhadap sistem komputer.

Pada perkembangannya, malware hadir dalam berbagai **varian** dan **sub-tipe**, seperti virus, trojan, spyware, *keylogger*, hingga ransomware. Setiap jenis malware memiliki karakteristik dan pola serangan yang berbeda, sehingga menantang para peneliti untuk menemukan teknik deteksi yang mampu mengenali pola berbahaya di tengah beragamnya jenis ancaman. Selain itu, para penyerang terus memperbarui teknik mereka agar malware dapat **berkembang secara dinamis**, misalnya melalui obfuskasi kode, polymorphic malware, atau memanfaatkan kerentanan baru. **Urgensi deteksi malware** terletak pada kebutuhan untuk **mengidentifikasi ancaman baru secara cepat** sebelum menimbulkan kerusakan yang luas. Dengan ancaman yang terus berevolusi, pendekatan deteksi konvensional semakin tertantang untuk memberikan perlindungan yang memadai.

## Kelemahan Metode Deteksi Tradisional

Selama bertahun-tahun, pendekatan paling umum untuk mendeteksi malware adalah metode **signature-based detection** (berbasis tanda tangan). Pada metode ini, tiap malware yang sudah diketahui akan dibuatkan “sidik jari” unik (misalnya pola byte code tertentu, hash MD5/SHA, atau urutan instruksi spesifik). Sistem antivirus tradisional kemudian memindai file atau program dan membandingkannya dengan basis data tanda tangan malware yang dikenal. **Kelemahan mendasar** dari pendekatan ini adalah ketidakmampuannya beradaptasi terhadap malware baru atau *varian* yang sedikit berubah. Penyerang dapat dengan mudah menghindari deteksi **hanya dengan melakukan modifikasi kecil pada kode** untuk mengubah tanda tangan digitalnya. Teknik polimorfisme dan obfuskasi kode dapat mengecoh algoritma pencocokan tanda tangan, karena *fingerprint* malware berubah dan tidak lagi cocok dengan pola yang ada di database. Akibatnya, **malware baru atau varian yang belum terdaftar** dapat luput dari deteksi, hingga tanda tangan baru dibuat dan ditambahkan secara manual ke database antivirus. Proses ini menciptakan pola permainan kucing-dan-tikus (*cat-and-mouse*) antara pembuat malware dan pembuat antivirus: begitu pola malware terdeteksi dan ditambahkan, penyerang merilis varian baru dengan pola berbeda, dan siklus ini berulang.

Keterbatasan lain dari deteksi berbasis tanda tangan adalah **ketergantungan pada pengetahuan sebelumnya**. Sistem tidak dapat mengenali ancaman *zero-day* (malware yang belum pernah diketahui sebelumnya) karena tidak ada referensi pola sama sekali. Hal ini menyebabkan jendela kerentanan di mana malware baru bebas beroperasi sebelum terdeteksi. Di samping itu, metode tradisional sering kali menghasilkan **positif-palsu** ataupun **negatif-palsu** jika kode malware sedikit menyerupai program benign atau sebaliknya, sehingga akurasinya menurun dalam lingkungan nyata yang kompleks.

Sebagai tanggapan atas kekurangan tersebut, industri keamanan siber mulai beralih ke metode **heuristic** dan **analisis perilaku**. Teknik **analisis dinamis menggunakan sandbox** muncul sebagai solusi inovatif untuk melampaui keterbatasan tanda tangan statis. Dalam pendekatan ini, file mencurigakan dijalankan di lingkungan terisolasi (*sandbox*), seperti mesin virtual, di mana segala aksi dan perilakunya dipantau. Alih-alih melihat kode biner statis, sistem memeriksa **jejak perilaku**: misalnya *API calls* (panggilan fungsi ke sistem operasi), perubahan registry, aktivitas jaringan, dan interaksi dengan sistem file. Snapshot atau log yang dihasilkan sandbox kemudian dianalisis untuk mendeteksi pola perilaku berbahaya. Jika dalam simulasi tersebut file mencoba tindakan mencurigakan (seperti mengakses layanan ilegal, mengenkripsi banyak file, atau mengirim data ke server asing), maka file tersebut dapat diidentifikasi sebagai malware meskipun kode binernya belum dikenali sebelumnya. Teknik sandbox ini revolusioner karena mampu **mengungkap malware baru** tanpa harus mengetahui tanda tangannya terlebih dahulu, sekaligus menjaga keamanan sistem asli (karena eksekusi terjadi di lingkungan virtual terkontrol).

Namun, **analisis sandbox/dinamis** pun tidak luput dari tantangan. Proses menjalankan file dalam virtual environment biasanya **lambat dan membutuhkan sumber daya besar**, sehingga sulit diterapkan untuk memeriksa ribuan file secara real-time. Beberapa malware canggih juga dilengkapi teknik anti-sandbox (misalnya menunda eksekusi atau mendeteksi jika berjalan di VM) untuk menghindari terdeteksi. Oleh karena itu, penelitian terkini mencoba memanfaatkan kemajuan di bidang **Machine Learning (ML)** dan **Artificial Intelligence (AI)** untuk meningkatkan deteksi malware. Salah satu pendekatan modern adalah **feature extraction** berbasis ML. Alih-alih membandingkan pola biner persis, metode ini mengekstraksi ciri-ciri penting dari file (misal: deret opcode, frekuensi API call, entropi byte, dll) dan melatih model ML untuk mengenali pola mana yang cenderung malicious. Karena berbasis pembelajaran, model dapat menangkap kemiripan antar malware meskipun detail kodenya tidak persis sama, sehingga **lebih robust** daripada metode tanda tangan statis. Selain itu, inovasi lain menggunakan **proses citra (image processing)** terhadap kode biner malware: misalnya mengonversi kode *hex* dari file executables menjadi **citra grayscale**, lalu menggunakan jaringan saraf convolutional (CNN) untuk mendeteksi pola visual yang mengindikasikan malware. Studi terdahulu menunjukkan bahwa pendekatan visulisasi binary ini dapat mencapai akurasi tinggi dengan membandingkan “citra” malware dengan pola citra malware yang sudah dikenal.

Semua perkembangan di atas menegaskan bahwa **deteksi malware modern bergerak ke arah yang lebih cerdas** dan adaptif. Dengan mengombinasikan analisis perilaku dinamis dan teknik *machine learning* (termasuk *deep learning*), diharapkan sistem deteksi mampu **mengimbangi evolusi malware** secara lebih proaktif. Paper *"Efficient Malware Detection using NLP and Deep Learning Model"* yang diulas di sini hadir dalam konteks tersebut, mengusulkan metode baru yang memanfaatkan **Natural Language Processing (NLP)** dan model *deep learning* untuk meningkatkan efektivitas deteksi malware.

## Metodologi yang Diusulkan

Dalam makalah ini, Gupta *et al.* (2025) mengusulkan sebuah kerangka deteksi malware berbasis **analisis perilaku** yang menggabungkan teknik **NLP untuk vektorisasi** data dan **jaringan saraf deep learning** sebagai pengklasifikasi. Tujuannya adalah menciptakan model yang mampu mengatasi kelemahan metode tradisional, dengan akurasi tinggi dan kemampuan beradaptasi terhadap malware baru. Gambar 1 dalam paper (tidak disertakan di sini) menggambarkan alur metodologi secara keseluruhan. Berikut penjelasan tiap komponen utama:

* **Pengumpulan Data Malware di Sandbox:** Pertama, penulis menggunakan *sandbox environment* **Cuckoo** yang dijalankan di dalam mesin virtual. Setiap sampel file (baik malware maupun benign) dieksekusi di sandbox ini untuk **mengobservasi perilakunya**. Sandbox mencatat berbagai aktivitas, terutama *kernel-level API calls* (panggilan sistem) yang dilakukan file tersebut selama eksekusi. **API calls** adalah panggilan fungsi ke kernel OS atau layanan sistem (misalnya membuka file, mengubah registri, membuat koneksi jaringan). Pola deret API call ini mencerminkan *behavior* malware: malware biasanya melakukan serangkaian panggilan spesifik untuk menjalankan aksinya (contoh: ransomware mungkin memanggil fungsi enkripsi file berulang kali, spyware mungkin mengakses fungsi pengambilan data pengguna, dll). Data perilaku ini diekstraksi dari sandbox dalam bentuk log atau laporan yang memuat urutan API call yang dipanggil oleh file uji.

* **Pre-processing dan Pembersihan Data:** Log mentah yang diperoleh dari sandbox kemudian diolah. Penulis mengubah log menjadi format **CSV (Comma Separated Values)** di mana tiap baris merepresentasikan satu sampel file. Setiap entri mencakup *hash* unik file (misal SHA-256), label kelas (malicious atau benign), dan **urutan API calls** yang terjadi saat file berjalan. Sebelum analisis lebih lanjut, data ini dibersihkan dengan **menghilangkan entri yang redundan** atau tidak relevan. Misalnya, jika ada API call berulang-ulang yang tidak menambah informasi, atau noise dari environment, itu akan dihapus. Selain itu, untuk memudahkan pemrosesan, penulis membatasi panjang urutan API call yang dipertimbangkan. Dari dataset asli yang memiliki hingga 175 panggilan per sampel, analisis menunjukkan hanya sebagian kecil sampel memerlukan urutan sepanjang itu (hanya \~100 sampel yang menggunakan semua 175 slot panggilan). Mayoritas sampel memiliki urutan yang jauh lebih pendek (sebagian besar di bawah 50 calls). Oleh karena itu, *truncation* diterapkan: hanya **50 API call pertama** dari setiap sampel yang digunakan untuk feature (jika sampel memiliki kurang dari 50, sisanya diisi tag “End” sebagai padding). Langkah ini mengurangi dimensi data secara drastis (sekitar 67% pengurangan dimensi matriks embedding) tanpa membuang banyak informasi penting, sehingga **mengurangi kompleksitas** komputasi model.

* **Representasi Vektor dengan NLP (BERT):** Bagian inti metodologi adalah menggunakan teknik *Natural Language Processing* untuk merepresentasikan deretan API call sebagai input numeric bagi model deep learning. Idenya didasarkan pada analogi bahwa **urutan API call dapat dianggap seperti kalimat dalam bahasa alami**, di mana setiap nama fungsi API adalah seperti sebuah "kata". Penulis memanfaatkan model bahasa **BERT** (Bidirectional Encoder Representations from Transformers) untuk melakukan **tokenisasi dan vektorisasi** dari token-token API tersebut. BERT adalah model *transformer* berkapasitas tinggi yang umum digunakan dalam NLP, mampu menghasilkan *embedding* (vektor densitas tinggi) dari kata atau frasa dengan mempertimbangkan konteks sekitarnya. Dalam konteks penelitian ini, setiap nama API call (misal: `CreateFile`, `RegOpenKey`, dll) diperlakukan sebagai token teks. Dengan **BERT tokenizer**, masing-masing token API diubah menjadi representasi numerik berukuran **768 dimensi** (BERT embedding vektor berukuran 768). Vektor 768-dimensi ini mencerminkan karakteristik “semantik” dari API tersebut menurut model BERT, sehingga API-API yang mirip (misal sama-sama fungsi file system) akan memiliki representasi yang relatif dekat di ruang vektor. Penulis memilih BERT karena merupakan model **state-of-the-art** dan open-source, dengan kosa kata besar dan kemampuan representasi yang andal untuk beragam token. Dengan BERT, diharapkan model dapat menangkap hubungan laten antar panggilan API yang mungkin tidak terlihat secara langsung oleh manusia. Setelah melalui BERT, setiap sampel file yang terdiri dari 50 API call akan menghasilkan **urutan 50 vektor**, masing-masing 768 dimensi. Hasilnya dapat dipandang sebagai sebuah matriks ukuran *50 x 768* untuk satu sampel.

* **Pembentukan Fitur Input:** Matriks embedding *50 x 768* tersebut kemudian di-*flatten* (dijatuhkan dimensinya) menjadi **vektor fitur panjang 38.400** (karena 50 \* 768 = 38.400). Vektor inilah yang menjadi representasi final setiap sampel malware/benign, menggabungkan informasi dari seluruh API calls yang diamati. Dengan cara ini, problem deteksi malware direduksi menjadi problem klasifikasi biner berbasis fitur-fitur vektor tinggi: model perlu memetakan vektor 38.400-dimensi ke kelas *malicious* atau *benign*. Sebelum pelatihan model, dataset vektor ini dibagi menjadi data **training** dan **testing** (dengan proporsi 80:20) menggunakan *shuffle split* acak. Dari total \~1793 sampel yang tersedia setelah praproses, sekitar 1.344 digunakan untuk melatih model dan sisanya (\~20%) untuk menguji performanya.

* **Arsitektur Model Deep Learning (Multilayer Perceptron):** Penulis membangun model *deep learning* berupa **Multilayer Perceptron (MLP)**, yaitu jaringan saraf tiruan feed-forward berlapis-lapis, untuk melakukan klasifikasi malware. Arsitektur yang diusulkan **sederhana namun efektif**, terdiri dari **3 lapis linear bertingkat** (dense layers) yang disusun sekuensial. Lapisan-lapisan ini saling terhubung penuh (fully-connected), dan di antara lapisan linear diberikan fungsi aktivasi non-linear untuk meningkatkan kapasitas model dalam memetakan fitur ke keluaran. Secara spesifik, penelitian ini mengeksplorasi penggunaan fungsi aktivasi **ReLU (Rectified Linear Unit)** dan **Tanh** pada lapisan-lapisan tersembunyi, untuk mencari kombinasi yang optimal. Arsitektur final *proposed model* yang memberikan hasil terbaik menggunakan fungsi aktivasi ReLU pada hidden layer (dijelaskan pada bagian hasil). Setiap neuron dalam jaringan memproses masukan linear (kombinasi linear dari semua fitur input, dikalikan bobot dan ditambah bias) kemudian diaplikasikan aktivasi. Dengan input berukuran 38.400 fitur, lapisan pertama mereduksi ke dimensi tertentu (jumlah neuron tersembunyi, misal 512 neuron – tidak disebutkan eksplisit, tetapi total parameter \~19,7 juta menunjukkan orde ratusan neuron). Lapis kedua mengambil keluaran lapis pertama dan mengubah ke dimensi lebih kecil lagi, dan akhirnya lapisan terakhir memetakan ke **1 neuron output**. Satu neuron output ini merepresentasikan skor kecenderungan file merupakan malware. Penulis menggunakan fungsi aktivasi **sigmoid** pada neuron output, sehingga keluaran akhir adalah nilai dalam rentang 0 hingga 1. Nilai ini kemudian diinterpretasi sebagai prediksi **binary**: jika output ≥ 0.5 dianggap *malicious*, sedangkan < 0.5 dianggap *benign*. Dengan demikian, arsitektur keseluruhan dapat disimpulkan sebagai: **\[Input 38.400-dim] → Linear( hidden layer 1 ) + Activation → Linear( hidden layer 2 ) + Activation → Linear( output layer 1 neuron ) + Sigmoid → Prediksi**.

* **Pelatihan Model:** Selama pelatihan, digunakan *loss function* berupa **Binary Cross-Entropy** yang cocok untuk tugas klasifikasi biner. Optimizer yang dipakai adalah **Stochastic Gradient Descent (SGD)** dengan laju pembelajaran (*learning rate*) relatif tinggi (0.025). Kombinasi ini dipilih untuk mempercepat konvergensi model mengingat jumlah data yang tidak terlalu besar. Selain itu, penulis menjalankan pelatihan menggunakan platform Google Colab dan hardware terbatas (RAM 8GB, tanpa GPU high-end), sehingga pendekatan MLP yang relatif ringan secara komputasi menjadi pilihan tepat dibanding model sekuensial kompleks. Settiap epoch pelatihan, model memperbarui bobotnya untuk meminimalkan loss, dan penulis memantau metrik seperti akurasi training vs testing seiring peningkatan epoch untuk memastikan model **tidak overfitting**.

* **Prinsip Analisis Perilaku:** Penting untuk dicatat bahwa keseluruhan pendekatan ini berlandaskan **analisis perilaku malware** (*behavioral analysis*). Model tidak melihat langsung kode biner malware, melainkan **pola perilaku yang terekam** (dalam hal ini deret panggilan API). Dengan kata lain, deteksi dilakukan berdasarkan *apa yang dilakukan* oleh program, bukan *bagaimana program itu tertulis* dalam kode. Ini sejalan dengan metode sandboxing yang telah dibahas, namun di sini pola perilaku tersebut diolah lebih lanjut dengan teknik NLP dan dipahami oleh jaringan saraf. **Keunggulan pendekatan ini** adalah kemampuan untuk mendeteksi malware baru yang mungkin kodenya berbeda tapi menunjukkan *jejak perilaku* yang serupa dengan malware sebelumnya (misal sama-sama mengakses API enkripsi file secara massal, dsb). Model berusaha menangkap *essence* dari perilaku berbahaya melalui representasi vektor dan bobot jaringan yang dilatih.

Dalam metodologi yang diusulkan, integrasi antara sandbox (sebagai sumber data perilaku) dan NLP (*BERT embedding*) menghasilkan cara pandang baru terhadap deteksi malware. Alih-alih menggunakan fitur statis yang telah ditentukan secara manual, model belajar **langsung dari data** untuk mengenali pola tersembunyi. Diharapkan, pendekatan *Efficient Malware Detection using NLP and Deep Learning* ini mampu **meningkatkan akurasi deteksi** sekaligus **mengurangi ketergantungan** pada update tanda tangan manual.

## Eksperimen, Dataset, dan Evaluasi Performa

Penulis melakukan serangkaian eksperimen untuk menguji model yang diusulkan, meliputi pembuatan dataset, pelatihan model, dan evaluasi menggunakan berbagai metrik (precision, recall, F1-score, dll). Berikut rincian penting dari eksperimen tersebut:

* **Dataset dan Sumber Data:** Karena kurangnya *dataset publik* yang persis sesuai kebutuhan (log API call dari sandbox), penulis memutuskan untuk **membangun dataset sendiri** dengan memanfaatkan sumber data yang tersedia. Dataset primer dibuat berdasarkan data dari repositori GitHub *mpasco*, yang nampaknya menyediakan kumpulan log atau data perilaku malware (mungkin dari penelitian sebelumnya). Selain itu, penulis juga menjalankan *sandbox* di mesin pribadi untuk mengumpulkan data tambahan sebagai **dataset sekunder** (digunakan untuk validasi). Total setelah penggabungan dan pembersihan, diperoleh **2570 sampel** yang terdiri dari kombinasi file malicious dan benign. Masing-masing sampel memiliki hingga 175 urutan API call, namun seperti dijelaskan di metodologi, banyak kolom yang kosong jika sampel tidak mencapai panjang tersebut. Setelah dilakukan pengurangan kolom menjadi 50 API call maksimal (menghapus 25% kolom paling sparse), ukuran dataset efektif menjadi **1793 sampel** (beberapa sampel mungkin dibuang karena redundansi atau kekurangan data). Dataset akhir ini seimbang memuat kedua kelas (malware dan benign) agar model tidak bias dalam pembelajaran.

* **Pembagian Data Latih dan Uji:** Dataset dipisahkan menjadi **train set (latih)** dan **test set (uji)** dengan komposisi 80% vs 20%. Dari 1793 total sampel, sekitar 1.344 digunakan untuk melatih model, dan 449 sisanya untuk menguji performa setelah model dilatih. Pemisahan dilakukan secara acak dengan *stratified sampling* (walau tidak disebutkan eksplisit, kemungkinan penulis memastikan proporsi malware/benign relatif seimbang di kedua subset). Selain itu, penulis juga menyiapkan **validation set** terpisah menggunakan dataset sekundernya (dari sandbox pribadi) sebagai tambahan evaluasi, mengingat data sekunder lebih kecil dan tidak cukup untuk masuk train set. Validation set ini membantu memastikan model tidak overfit pada data primer saja.

* **Pelatihan Model:** Model MLP dilatih dengan hyperparameter yang telah disebutkan (optimizer SGD, LR 0.025, loss binary cross-entropy). Karena jumlah parameter model cukup besar (\~19,7 juta) namun data relatif sedikit, penulis berhati-hati terhadap *overfitting*. Dari grafik pelatihan (Gambar 12 dan 13 di paper), akurasi *training* dan *testing* meningkat seiring epoch, dengan lompatan akurasi signifikan di epoch awal. Ini menandakan model awalnya belajar cepat dari data training dan kemudian mampu **mulai mengenali pola** di data testing setelah melewati bias awal (indikasi bahwa model tidak sekadar menghapal training set, tetapi benar-benar generalisasi). Selama training, penulis juga memantau *loss* dan mungkin menggunakan *early stopping* jika kinerja mulai stagnan atau memburuk di validation, meskipun detail ini tidak dijelaskan panjang lebar.

* **Metrik Evaluasi:** Untuk mengevaluasi model, penulis menggunakan beragam metrik standar klasifikasi: **Accuracy, Precision, Recall, F1-Score**, serta analisis kurva **Precision-Recall** dan **ROC (Receiver Operating Characteristic)**. Penggunaan beberapa metrik ini penting mengingat dalam deteksi malware, **false positive** (FP) dan **false negative** (FN) memiliki dampak yang berbeda. *Precision* tinggi berarti sedikit FP (hampir semua yang ditandai malware benar-benar malware), sedangkan *Recall* tinggi berarti sedikit FN (hampir semua malware berhasil terdeteksi). *F1-Score* merupakan rata-rata harmoni dari precision dan recall, sering dipakai sebagai indikator keseluruhan keseimbangan model. Di sisi lain, *Accuracy* saja bisa menyesatkan jika dataset tidak seimbang, namun dalam konteks ini dataset relatif berimbang antar kelas. Penulis juga memvisualisasikan **kurva Precision-Recall** model utama (Gambar 14) serta **kurva ROC** (Gambar 15) untuk melihat trade-off model dalam berbagai threshold klasifikasi.

* **Hasil Performa Model (MLP dengan BERT):** Model deteksi malware yang diusulkan menunjukkan **kinerja yang sangat baik** pada data uji. Dari tabel evaluasi (Table 5), model MLP memperoleh **akurasi sekitar 89.3%** pada test set. Lebih detail lagi, *precision* model mencapai **87.17%**, *recall* sekitar **84.55%**, dengan **F1-Score ≈ 0.859** (85.9%). Nilai precision \~87% mengindikasikan bahwa dari semua prediksi "malicious" yang dibuat model, 87% di antaranya memang malware sebenarnya (hanya 13% false alarm). Sementara recall \~84.5% berarti dari semua malware sebenarnya di dataset, \~84.5% berhasil tertangkap oleh model (ada sekitar 15.5% yang lolos sebagai false negative). Keseimbangan metrik ini sangat penting: model **tidak hanya akurat secara keseluruhan, tapi juga memiliki keseimbangan baik** antara menangkap malware dan menghindari false alarm. Skor F1 \~0.85 mengafirmasi hal tersebut. Untuk konteks, performa ini **jauh melampaui pendekatan tradisional berbasis tanda tangan**, yang praktis memiliki recall 0% untuk malware baru hingga tanda tangan tersedia. Juga, jika dibandingkan metrik *Precision-Recall* approach lain (misal model RNN dalam eksperimen penulis sendiri, lihat bagian berikut), model ini unggul.

* **Analisis Kurva PR dan ROC:** Kurva Precision-Recall model menunjukkan hasil yang memuaskan. Penulis mencatat bahwa grafik PR mendekati sudut atas kanan (mendekati nilai 1 pada kedua sumbu), yang berarti model mampu menjaga precision dan recall tinggi secara simultan. Hal ini menandakan **model jarang salah** dalam menandai file benign sebagai malware (**FP rendah**), sekaligus **jarang melewatkan** malware sebenarnya (**FN rendah**). Sementara itu, kurva ROC model (plot TPR vs FPR) berada jauh di atas garis diagonal acak, meskipun tidak mencapai sempurna di pojok atas kiri. Area di bawah kurva (AUC) yang besar menunjukkan model memiliki *discrimination power* yang kuat untuk membedakan malware vs benign. Penulis mengamati bahwa kurva ROC agak **tertarik ke atas** (skewed) ke arah tinggi *True Positive Rate* namun dengan sedikit peningkatan *False Positive Rate*, menyiratkan model cenderung **berhati-hati** dengan **kecenderungan lebih sensitif (mengorbankan sedikit spesifisitas)**. Dalam keamanan siber, kecenderungan seperti ini sering dapat diterima karena lebih baik mengidentifikasi sebanyak mungkin malware (meski ada sedikit false alarm) daripada melewatkan ancaman nyata. Meskipun demikian, penulis mengakui modelnya **belum sempurna**, sebagian karena keterbatasan ukuran data latih yang relatif kecil, sehingga ada ruang untuk peningkatan lebih lanjut.

Singkatnya, eksperimen menunjukkan bahwa integrasi **NLP (BERT embedding)** dengan **MLP** menghasilkan model deteksi malware yang **akurat dan adaptif**. Model ini berhasil mempelajari pola perilaku berbahaya dari data sandbox dan mencapai metrik evaluasi tinggi (akurasi \~89%, F1 \~0.85). Selanjutnya, untuk memahami keunggulan model ini, penulis juga melakukan **perbandingan** dengan pendekatan lain, terutama model *baseline* menggunakan **RNN (Recurrent Neural Network)**, yang akan dibahas di bagian berikut.

## Perbandingan dengan Pendekatan Lain (Eksperimen RNN dan Model Alternatif)

Untuk menilai efisiensi dan efektivitas model yang diusulkan, Gupta *et al.* membandingkannya dengan beberapa pendekatan alternatif. Salah satu yang diujicobakan secara langsung adalah model **Recurrent Neural Network (RNN)** tipe LSTM, mengingat data API call sebenarnya berupa **urutan sekuensial** yang secara alami cocok ditangani RNN. Selain itu, penulis juga melakukan *ablation* dengan membandingkan pengaruh berbagai fungsi aktivasi pada MLP (ReLU vs Tanh). Berikut rangkuman perbandingan tersebut:

* **Eksperimen Model RNN:** Penulis membangun sebuah model RNN (dengan lapisan LSTM) yang mengambil deret API call sebagai input berurutan dan menghasilkan prediksi malware/benign. Ideanya, RNN dapat **memanfaatkan urutan temporal** dari API calls, berbeda dengan MLP yang menganggap input sebagai fitur flat. Namun, hasil eksperimen menunjukkan bahwa **kinerja RNN jauh di bawah ekspektasi**. Model RNN hanya mencapai akurasi sekitar **55.4%** pada data uji, dengan precision sekitar **51.6%** dan recall **40.8%** (F1-Score \~0.456). Angka ini bermakna bahwa RNN sering salah prediksi (nyaris setengah prediksinya keliru) dan gagal menangkap mayoritas malware (hanya 40% malware terdeteksi). Mengapa model sekuensial ini performanya **begitu rendah**? Penulis memberikan beberapa analisis: Pertama, **RNN rentan terhadap ukuran dataset yang kecil**. Dengan hanya \~1.3k sampel latih dan urutan relatif pendek (max 50), LSTM kesulitan **menggeneralisasi pola** dan cenderung overfitting atau *underfitting*. Kedua, **biaya komputasi RNN lebih tinggi** – setiap langkah input harus diproses berurutan, sehingga melatih RNN memakan waktu dan sumber daya lebih besar dibanding MLP feed-forward. Penulis mencatat bahwa *“karena kebutuhan komputasi ekstra untuk memproses bahkan sekumpulan kecil string, RNN gagal menggeneralisasi pada data berukuran kecil”*. RNN menunggu sampai elemen urutan terakhir sebelum memproduksi output, sehingga jika urutan panjang, gradien harus *backpropagate* melalui banyak langkah (*vanishing gradients* bisa terjadi). Dalam kasus ini, meski urutan 50 tidak terlalu panjang, ukuran data latih yang terbatas membuat RNN sulit belajar representasi yang robust. Alasan ketiga, kemungkinan RNN memerlukan **penyesuaian hiperparameter lebih rumit** dan butuh *regularization* kuat agar bisa bersaing, yang mungkin tak optimal dalam eksperimen terbatas ini. Hasil RNN yang buruk menunjukkan bahwa **sekadar menggunakan arsitektur sekuensial tidak otomatis lebih baik** apabila data tidak mencukupi atau model tidak di-tune dengan baik. Ini justru menguatkan argumen penulis untuk menggunakan pendekatan berbeda (NLP+MLP) yang terbukti lebih efisien pada konteks data mereka.

* **Perbandingan MLP (ReLU vs Tanh) dan Model Akhir:** Penulis juga mencoba variasi pada arsitektur MLP, khususnya mengganti fungsi aktivasi. Dua varian yang diuji adalah **MLP dengan ReLU** dan **MLP dengan Tanh** pada hidden layer. Hasilnya, kedua varian MLP ini sebenarnya sudah jauh mengungguli RNN. MLP + ReLU mendapat akurasi \~83.9%, precision \~83.4%, recall \~87.9%, F1 \~0.844. Sementara MLP + Tanh akurasinya mirip (\~83.2%), namun dengan **precision lebih rendah \~72.9% dan recall lebih tinggi \~88.8%** (F1 \~0.801). Ini menunjukkan bahwa fungsi aktivasi memengaruhi *trade-off* precision vs recall: pada Tanh, model cenderung menghasilkan lebih banyak positif (sehingga recall tinggi, menangkap hampir 89% malware) tetapi dengan konsekuensi false positive lebih banyak (precision turun ke \~73%). Sebaliknya ReLU memberikan precision dan recall yang lebih seimbang di kisaran \~83-88%. **Model akhir yang diusulkan (Proposed MLP)** ternyata memiliki performa lebih baik lagi: akurasi naik menjadi **89.3%**, precision **87.2%**, recall **84.5%**, F1 \~0.859. Angka ini lebih unggul dibanding kedua varian sebelumnya. Walaupun penulis tidak merinci semua perubahan yang diterapkan pada "Proposed MLP", dari konteks bisa diduga bahwa model final menggunakan **aktivasi ReLU** (atau mungkin kombinasi ReLU di hidden layer dan lapisan output sigmoid seperti sebelumnya) ditambah **penyetelan parameter/hyperparameter lebih lanjut**. Bisa jadi penulis mencoba menambah epoch, mengubah learning rate, atau menerapkan teknik regularisasi (dropout/batch norm) untuk mencapai peningkatan tersebut. Hasil akhirnya, *Proposed MLP* berhasil menekan jumlah **False Positives** sangat rendah (FP hanya 5 kasus pada confusion matrix) dan False Negative 44 kasus – jauh lebih baik daripada RNN (FP 78, FN 137) maupun MLP awal. Dengan FP hanya 5 terhadap ratusan sampel uji, precision-nya melonjak ke \~87%, menunjukkan model ini **sangat efisien**: ia nyaris tidak salah mengklasifikasikan data benign sebagai malware (hal ini penting agar solusi praktis tidak terlalu mengganggu pengguna dengan alarm palsu).

Selain membandingkan model yang dibangun sendiri, penulis juga mendiskusikan **pendekatan lain dari literatur** dalam bagian *Related Work*. Disebutkan sejumlah algoritma *machine learning klasik* (K-NN, Random Forest, Decision Tree, Logistic Regression, dll) maupun *deep learning* lain yang telah dicoba di ranah deteksi malware. Tren umum dari penelitian-penelitian sebelumnya menunjukkan bahwa mengombinasikan metode supervised dan unsupervised learning dapat meningkatkan deteksi, dan penggunaan model deep learning (CNN, autoencoder, pre-trained models) untuk analisis malware – baik berbasis kode maupun citra – telah mencapai kinerja yang menjanjikan. Misalnya, ada pendekatan yang menggunakan **autoencoder** untuk merekonstruksi citra biner malware grayscale dan menggunakan error rekonstruksi sebagai indikator malware. Juga eksperimen yang menunjukkan model CNN dan autoencoder *pre-trained* dapat mendeteksi malware dengan baik. Dalam konteks ini, inovasi Gupta *et al.* terletak pada penggunaan **transformer language model (BERT)** untuk analisis *behavioral log*, yang belum banyak dieksplor sebelumnya.

Hasil perbandingan secara keseluruhan memperlihatkan bahwa **model MLP dengan fitur NLP (BERT)** mengungguli RNN pada dataset ini, baik dari segi akurasi maupun efisiensi komputasi. Hal ini menegaskan klaim bahwa pendekatan yang diusulkan memang **efisien** (sesuai judul paper) dan efektif untuk tugas deteksi malware. RNN yang secara teoretis cocok untuk data sequential ternyata kalah karena kendala data dan resource, sedangkan model feed-forward sederhana mampu bekerja baik berkat representasi fitur yang kuat dari BERT.

## Kelebihan Model yang Diusulkan

Berdasarkan pemaparan di atas, model deteksi malware yang diusulkan memiliki sejumlah **kelebihan utama**:

* **Akurasi dan Performa Tinggi:** Model berhasil mencapai akurasi \~89% dengan precision-recall seimbang (sekitar 85-87%). Ini menandakan kinerja yang **sangat baik** dalam mendeteksi malware, dengan tingkat kesalahan rendah. *Precision* tinggi berarti model jarang memberikan alarm palsu (false positive minim), sedangkan *recall* tinggi berarti sebagian besar malware berhasil terdeteksi. Kinerja ini jauh lebih baik daripada baseline RNN (akurasi 55%) maupun metode tanda tangan tradisional (yang umumnya gagal untuk malware baru sama sekali).

* **Adaptif terhadap Malware Baru:** Tidak seperti metode signature-based yang kaku, model ini **belajar pola perilaku** sehingga dapat beradaptasi mendeteksi varian baru malware. Dengan mengandalkan fitur API call yang diekstraksi secara dinamis, model dapat mengenali **kemiripan perilaku** antara malware baru dan malware lama tanpa perlu pola kode yang identik. Penulis menekankan bahwa penggunaan **NLP pada deret fungsi** dan teknik *deep learning* membuat deteksi lebih **adaptif dan fleksibel**, mampu mengatasi keterbatasan metode tradisional yang tidak bisa menanggulangi evolusi malware yang dinamis.

* **Efisiensi Komputasi dan Kesederhanaan Model:** Dibandingkan model sekuensial (RNN/LSTM) atau CNN yang kompleks, arsitektur MLP yang digunakan relatif **sederhana** (hanya 3 lapisan linear) dan **efisien dihitung**. Ini mengakibatkan waktu pelatihan dan inferensi yang lebih singkat. Penulis mencatat bahwa model yang diusulkan dipilih karena memberikan hasil terbaik **dengan beban komputasi paling rendah** sesuai kebutuhan mereka. Dalam konteks implementasi nyata, efisiensi ini penting agar sistem deteksi dapat beroperasi dalam waktu nyata (real-time) atau skala besar.

* **Menggunakan Informasi Kontekstual via NLP:** Inovasi utama model adalah pemanfaatan **BERT embedding** yang secara implisit memasukkan *pengetahuan bahasa* ke dalam analisis API call. Ini merupakan kelebihan karena BERT dapat menempatkan token API dalam *vector space* yang bermakna, sehingga model akhir bisa mendapatkan *“pemahaman”* tertentu tentang fungsi-fungsi tersebut. Misalnya, BERT mungkin memahami bahwa token `CreateFile` dan `WriteFile` memiliki konteks yang berhubungan (sama-sama beroperasi pada file), sehingga meski urutan tepat API berbeda, model dapat menangkap esensi bahwa malware melakukan operasi file berbahaya. Pendekatan NLP ini unik dan menjadi nilai tambah model dalam hal **representasi fitur yang kaya**.

* **Validasi dengan Berbagai Metrik dan Visualisasi:** Penulis melakukan evaluasi komprehensif (akurasi, precision, recall, F1, PR curve, ROC curve) untuk memastikan model **handal secara menyeluruh**. Misalnya, kurva PR yang mendekati (1,1) menunjukkan kelebihan model dalam mempertahankan precision dan recall tinggi sekaligus. Hal ini mengindikasikan model bekerja konsisten di berbagai threshold, bukan hanya pada titik potong 0.5 tertentu. Keandalan across metrics ini penting untuk kepercayaan penerapan model di lapangan.

* **Berbasis Analisis Perilaku – Tahan Obfuskasi:** Karena model menganalisis perilaku runtime (API calls) alih-alih kode statis, **teknik obfuskasi atau enkripsi malware** yang biasanya mengecoh signature-based detection tidak akan langsung menggagalkan model ini. Selama malware tersebut melakukan aksi-aksi mencurigakan saat dijalankan (yang umumnya pasti, jika ingin menimbulkan efek merusak), model berpeluang mendeteksinya. Dengan kata lain, **evasiveness static tidak banyak berpengaruh**, selama perilaku dinamisnya tertangkap sandbox. Ini keunggulan inheren pendekatan dynamic + ML dibanding static.

## Keterbatasan Model dan Penelitian

Di balik kelebihannya, tentu model ini **memiliki keterbatasan** dan area yang memerlukan perbaikan. Penulis secara jujur mengidentifikasi beberapa keterbatasan dan tantangan yang dihadapi:

* **Tidak Memanfaatkan Urutan (*Sequence*) Secara Penuh:** Meskipun data asli berupa urutan API calls, arsitektur final model (MLP feed-forward) **tidak secara eksplisit memodelkan keterurutan/time-step**. Setelah proses BERT embedding, urutan 50 panggilan API memang disusun linear dalam vektor, namun hubungan antar posisi kemungkinan **kurang ditangkap** oleh MLP. Urutan panggilan dapat penting – misal, memanggil `OpenProcess` lalu `WriteProcessMemory` kemudian `CreateRemoteThread` berurutan jelas pola injeksi malware, tapi MLP mungkin sulit memahami pola kronologis ini karena *shallow*. Penulis menyebut kelemahan ini sebagai kurangnya aspek **"proceduralism"**, di mana pendekatan mereka **tidak melibatkan metode sekuensial** padahal malware jelas bekerja secara berurutan. Hal ini mengakibatkan model mengabaikan bagaimana *urutan* dan *dependensi antar panggilan* terjadi. Sebagai contoh, model mungkin memperlakukan kumpulan API calls secara *bag-of-words* – fokus pada frekuensi atau keberadaan jenis call, bukan urutannya. Ini bisa menjadi titik lemah jika urutan tindakan tertentu krusial untuk identifikasi (beberapa serangan mungkin baru terdeteksi dari pola *sequence* khusus).

* **Kecenderungan Mengabaikan Dampak Saling Ketergantungan Aksi:** Terkait poin di atas, model saat ini tidak menyoroti bagaimana **satu fungsi mempengaruhi fungsi berikutnya** dalam malware. Dalam malware kompleks, sering ada *stage* bertahap: misal pertama escalates privilege, lalu menanam payload, lalu membersihkan jejak. Urutan dan keterkaitan langkah-langkah ini penting dikenali. Dengan MLP biasa, interaksi antar langkah sukar tersurat. Penulis mengakui modelnya **mengabaikan bagaimana satu panggilan dapat memengaruhi panggilan lain yang datang setelahnya**. Ini area yang memerlukan perhatian di riset lanjutan.

* **Ketergantungan pada Data Sandbox (Keterbatasan Dataset):** Untuk menghasilkan prediksi, model memerlukan **data perilaku dari sandbox**. Ini membawa konsekuensi praktis: proses deteksi tidak bisa lebih cepat daripada waktu eksekusi sampel di sandbox. Jika malware perlu dijalankan 30 detik untuk mengumpulkan log, deteksi “cepat” tetap minimal mengikuti durasi tersebut. Selain itu, pembuatan dataset sandbox dalam jumlah besar sangat menantang. Penulis mengakui bahwa **mengumpulkan log malware via sandbox memakan banyak waktu** dan daya komputasi. Dalam penelitian ini mereka terbantu oleh data publik, namun untuk peningkatan lebih lanjut, perlu memperluas dataset (lebih banyak sampel, variasi jenis malware, dll). **Kurangnya data** merupakan keterbatasan klasik yang juga dialami di studi ini — model dilatih pada \~1k sampel, jumlah yang relatif kecil untuk deep learning. Hal ini membatasi generalisasi model untuk kasus real-world yang lebih bervariasi. Penulis menyebut modelnya **dibangun dalam keterbatasan sumber daya komputasi tinggi dan kurang data**, sehingga perlu dilatih ulang pada data lebih besar dengan resource memadai agar benar-benar siap terapkan di dunia nyata.

* **Model Cenderung *Bias* ke Positif:** Dari analisis ROC sebelumnya, terindikasi model condong untuk **“aman-side”** dengan lebih sering memberi predikat malicious (positif) demi menangkap malware sebanyak mungkin. Akibatnya false positive meski rendah namun tidak nol. Dalam setting operasional, terlalu banyak false positive bisa mengganggu. Meskipun precision model \~87% cukup tinggi, dalam volume besar alarm, 13% di antaranya palsu bisa jadi angka signifikan. Jadi, perlu dipertimbangkan mekanisme untuk mengendalikan FP, misal threshold yang lebih seimbang sesuai toleransi sistem atau *post-processing* hasil model dengan rule-based filtering tambahan.

* **Jangkauan Fitur Terbatas:** Model saat ini hanya menggunakan **API calls** sebagai sumber fitur perilaku. Padahal perilaku malware bisa juga tercermin dari aspek lain, misalnya **resource usage** (pemakaian CPU/memori anomali), interaksi jaringan, perubahan file system, dsb. Penulis sempat mencoba bereksperimen dengan fitur lain, tetapi tidak dilanjutkan karena keterbatasan waktu/data. Artinya, ada peluang bahwa menggabungkan **multi-modal features** (contoh: API calls + statistik resource + jejak network) dapat meningkatkan kemampuan deteksi. Keterbatasan fokus pada satu jenis fitur saja bisa membuat model melewatkan indikator lain di malware yang mungkin tidak muncul di API calls.

* **Belum Diuji di Beragam Platform:** Meskipun tidak disebut eksplisit, dataset *mpasco* kemungkinan besar berisi log API calls Windows (karena Cuckoo sandbox sering digunakan untuk Windows malware). Model mungkin **belum teruji** untuk malware di platform lain seperti Android, Linux, atau MacOS. Setiap platform memiliki API dan pola berbeda; model perlu disesuaikan ulang jika hendak digunakan secara lintas platform.

Penulis sangat menyadari keterbatasan-keterbatasan di atas dan menjadikannya landasan untuk **pekerjaan di masa depan**. Dalam makalah, mereka menggarisbawahi perlunya mengatasi aspek sequential dengan **model transformatif yang lebih baik atau LSTM yang ditingkatkan** supaya urutan aksi malware dapat tertangkap. Mereka juga menyarankan penggunaan **model atensi (attention mechanisms)** untuk memahami hubungan antar panggilan (misal dengan Transformer encoder yang memantau bagaimana satu token API terkait dengan token lain). Terakhir, menambah ukuran dataset dan menggunakan sumber daya komputasi yang lebih kuat menjadi agenda penting agar model dapat *scale up* dan **siap digunakan secara praktis**.

## Potensi Implementasi dan Arah Penelitian Lanjutan

Pendekatan deteksi malware berbasis NLP dan deep learning yang diusulkan ini membuka berbagai peluang implementasi di dunia nyata, sekaligus meninggalkan sejumlah pertanyaan penelitian lanjutan yang menarik untuk dieksplorasi:

* **Integrasi dengan Sistem Keamanan yang Ada (XDR/SIEM):** Penulis mencatat bahwa saat ini para penyedia keamanan siber terkemuka telah menerapkan konsep **XDR (Extended Detection and Response)**, di mana data perilaku file dari berbagai endpoint dikirim ke cloud untuk dianalisis secara terpadu. Dalam konteks ini, model *malware classifier* berbasis sandbox + NLP dapat diintegrasikan sebagai **lapisan analitik tambahan** di infrastruktur XDR. Misalnya, ketika sebuah file mencurigakan terdeteksi di endpoint, file tersebut otomatis dijalankan di sandbox cloud, log perilakunya dikirim ke modul deteksi berbasis model ini, dan hasil klasifikasi (malicious/benign) dikembalikan ke sistem untuk tindakan respons. Hal ini dapat terjadi secara *real-time* mengingat model MLP cukup ringan. Dengan integrasi semacam ini, **implementasi model tidak perlu di perangkat pengguna** (yang mungkin berat), melainkan di cloud security backend, sehingga meminimalkan dampak ke end-user. Penulis sendiri berencana menerapkan deteksi berbasis sandbox semacam ini untuk memberikan konteks tambahan dalam deteksi malware berbasis cloud.

* **Penggunaan di Sistem Antivirus Generasi Berikutnya:** Model ini juga dapat menjadi bagian dari **antivirus modern** sebagai komponen *behavior analysis*. Antivirus tradisional dapat ditingkatkan dengan modul AI: ketika scan statis meragukan, file dieksekusi di sandbox mini dan model ML menentukan jahat/tidaknya. Ini memungkinkan deteksi **zero-day malware** lebih handal tanpa menunggu update signature. Potensi implementasi lainnya adalah di **gateway jaringan atau firewall**, di mana lampiran email atau file download bisa diuji di sandbox otomatis sebelum diizinkan masuk ke jaringan internal.

* **Optimisasi Model untuk Produksi:** Untuk implementasi luas, model perlu dioptimalkan. Salah satu langkah mungkin adalah **mengompresi model** atau menggunakan versi **BERT yang lebih kecil** (misal *DistilBERT* atau *TinyBERT*) untuk mempercepat inferensi. Juga, melatih ulang model dengan dataset yang lebih besar dan representatif akan diperlukan agar model robust terhadap berbagai skenario. Mengingat model ini memiliki \~19 juta parameter MLP + komponen BERT (jika BERT difine-tune), maka penggunaan teknik *model quantization* atau *knowledge distillation* bisa dipertimbangkan agar lebih ringan di deployment.

* **Arah Riset Lanjutan – Model Berbasis Urutan:** Seperti dijelaskan di bagian keterbatasan, langkah alamiah berikutnya adalah merancang **model sekuensial atau berkemampuan atensi** untuk mengatasi hilangnya informasi urutan. Riset lanjutan dapat menjajaki penggunaan **Transformer encoder** yang langsung melahap urutan API calls sebagai input (mirip cara kerja BERT, tapi ditraining end-to-end untuk tugas deteksi malware). Model transformer semacam itu akan *learn* representasi internal di mana relasi antar API call dipertimbangkan melalui mekanisme attention. Alternatif lain, mengadopsi **LSTM/GRU** dengan teknik regularisasi yang kuat dan mungkin ditambahkan lapisan attention di atasnya, sehingga model fokus pada urutan panggilan yang paling “mencurigakan”. Penulis menyarankan pemanfaatan **improved transformer models atau LSTM** untuk menjaga urutan operasi, dan **attention models** untuk menangkap dampak antar panggilan. Ini merupakan arah riset penting yang bisa meningkatkan kemampuan deteksi secara signifikan.

* **Multi-modal Malware Analysis:** Riset lanjutan bisa memperluas jenis data yang dipakai. Misalnya, mengombinasikan **fitur dynamic dan static**: model dapat diberi dua input, satu berupa embedding API calls (dynamic) dan satu lagi embedding dari binary code/static features (misal n-gram opcode atau image grayscale). Pendekatan **multi-modal deep learning** ini mungkin menghasilkan model yang lebih tangguh – ia bisa mendeteksi malware bahkan jika salah satu sumber data dimanipulasi. Selain itu, menambahkan fitur lain seperti jejak jaringan (apakah melakukan koneksi ke domain berbahaya), atau anomali penggunaan sumber daya, bisa menjadi sinyal tambahan yang meningkatkan akurasi.

* **Evaluasi Lintas Domain:** Menarik pula untuk menguji atau mengadaptasi model ini ke domain lain. Misalnya, **deteksi malware Android** dengan konsep serupa: alih-alih Windows API calls, model bisa menganalisis deret panggilan API Android atau sistem log perilaku aplikasi. Tantangannya, tentu, menyiapkan dataset yang sesuai. Demikian juga, eksplorasi ke malware IoT atau ICS (Industrial Control Systems) dimana perilaku mungkin berbeda, bisa menjadi perluasan riset.

* **Pengembangan *Custom NLP* untuk Malware:** Penulis sempat menyinggung kemungkinan pembuatan **tokenizer khusus (Byte Pair Encoding) untuk API calls** namun dibatalkan karena pertimbangan memori. Ke depan, penelitian dapat membuat *language model* khusus di domain malware (semacam *MalwareBERT*), dilatih dari kumpulan besar nama API, opcode, string malware, dsb, sehingga menghasilkan embedding yang lebih khusus domain daripada BERT umum. Model khusus ini bisa jadi lebih baik menangkap nuansa yang unik di data malware.

* **Kolaborasi dengan Sistem Deteksi Lain:** Implementasi model AI tidak harus berdiri sendiri. Bisa dibayangkan **sistem hybrid** di mana hasil dari model NLP+ML ini digabung dengan indikator lain (misal rule-based, atau hasil sandbox tradisional) untuk membuat keputusan final. Pendekatan *ensemble* atau *stacking* beberapa model deteksi mungkin meningkatkan akurasi dan menurunkan false rate lebih lanjut.

Sebagai kesimpulan, paper *Efficient Malware Detection using NLP and Deep Learning Model* menawarkan **kontribusi berharga** dengan memanfaatkan teknik *state-of-the-art* NLP dalam domain keamanan siber. Model yang diusulkan menunjukkan **hasil yang menjanjikan** dalam mengklasifikasikan malware vs benign secara efisien. Dengan latar belakang urgensi ancaman malware yang terus berkembang, pendekatan ini memberi arah baru bagaimana *machine learning* dapat diterapkan untuk keamanan: memadukan analisis perilaku dinamis dengan kecerdasan bahasa mesin. Tentu, masih banyak ruang penyempurnaan, terutama dalam menangani aspek sekuensial dan memperluas cakupan data. Namun, studi ini membuktikan bahwa **pendekatan interdisipliner (NLP + cybersecurity)** dapat menghasilkan solusi deteksi malware yang lebih tangguh dan adaptif, selangkah lebih maju melampaui metode klasik. Penelitian lanjutan yang mengatasi keterbatasan dan mengeksplorasi ide-ide baru di atas sangat dinantikan, demi mewujudkan sistem deteksi malware generasi berikutnya yang *canggih, efisien, dan proaktif* dalam melindungi infrastruktur digital kita.

**Referensi:**

Gupta, U., *et al.* (2025). *Efficient Malware Detection using NLP and Deep Learning Model*. Alexandria Engineering Journal, 124, 550–564. (doi:10.1016/j.aej.2025.03.118) (termasuk sumber data dan kutipan sesuai konteks di atas).
